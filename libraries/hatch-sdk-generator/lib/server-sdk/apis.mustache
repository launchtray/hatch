/* tslint:disable */
/* eslint-disable */
{{>licenseInfo}}
import {
  controller,
  route,
} from '@launchtray/hatch-server';
import {BasicRouteParams} from '@launchtray/hatch-server-middleware';
import {inject, Logger} from '@launchtray/hatch-util';
import {
  DependencyContainer,
  resolveParams,
} from '@launchtray/tsyringe-async';
import {
  AlternateAction,
  ControllerDelegateResponse,
  handleAlternateActions,
  route_GET,
  route_POST,
  route_PUT,
  route_PATCH,
  route_DELETE,
  route_HEAD,
} from '../runtime';
{{#imports.0}}
import {
  {{#imports}}
  {{className}},
  {{className}}FromJSON,
  {{className}}ToJSON,
  {{/imports}}
} from '../models';
{{/imports.0}}
{{#operations}}
{{#operation}}

interface {{operationIdCamelCase}}RequestContext {
  {{#bodyParam}}
  {{#dataType}}
  body: {{dataType}};
  {{/dataType}}
  {{/bodyParam}}
}

interface {{operationIdCamelCase}}ResponseContext {
{{#returnType}}
  body: {{returnType}};
{{/returnType}}
  httpCode?: number;
}
{{/operation}}
{{/operations}}

export interface {{classname}}ControllerDelegate {
  {{#operations}}
  {{#operation}}
  handle{{operationIdCamelCase}}(
    request: {{operationIdCamelCase}}RequestContext,
    ...optionalInjections
  ): ControllerDelegateResponse<{{operationIdCamelCase}}ResponseContext{{^returnType}} | void{{/returnType}}>;
  {{/operation}}
  {{/operations}}
}

@controller({autoInject: false})
export default class {{classname}}Controller {
  constructor(
    @inject('Logger') private readonly logger: Logger,
    private readonly delegate: {{classname}}ControllerDelegate,
  ) {
  }
  {{#operations}}
  {{#operation}}

  @route_{{httpMethod}}('{{path}}'.replace(/{([^}]*)}/g,':$1'))
  async handle{{operationIdCamelCase}}(requestContainer: DependencyContainer) {
    const basicRouteParams = await requestContainer.resolve(BasicRouteParams);
    const requestContext: {{operationIdCamelCase}}RequestContext = {
      {{#bodyParam}}
      body: {{dataType}}FromJSON(basicRouteParams.req.body),
      {{/bodyParam}}
    };
    const target = this.delegate.constructor.prototype;
    const args = await resolveParams(requestContainer, target, '{{dataType}}');
    try {
      const delegateResponse: {{#returnType}}{{operationIdCamelCase}}ResponseContext | {{/returnType}}AlternateAction | undefined = await this.delegate.handle{{operationIdCamelCase}}.apply(
        this.delegate,
        [requestContext, ...args],
      );
      if (handleAlternateActions(delegateResponse, basicRouteParams)) {
        return;
      }
      {{#returnType}}
      const responseJson = {{returnType}}ToJSON(delegateResponse.body);
      basicRouteParams.res.status(delegateResponse?.httpCode ?? 200).send(responseJson);
      {{/returnType}}
      {{^returnType}}
      basicRouteParams.res.sendStatus(200);
      {{/returnType}}
    } catch (err: unknown) {
      basicRouteParams.res.status(500).send((err as {message?: string}).message ?? '');
    }
  }
  {{/operation}}
  {{/operations}}
}



///////////////////////////////////////////////////


{{#operations}}
/**
 * {{#lambda.indented_star_1}}{{{unescapedDescription}}}{{/lambda.indented_star_1}}
 */
{{#withInterfaces}}
export class {{classname}} extends runtime.BaseAPI implements {{classname}}Interface {
{{/withInterfaces}}
{{^withInterfaces}}
export class {{classname}} extends runtime.BaseAPI {
{{/withInterfaces}}

  {{#operation}}
  /**
   {{#notes}}
   * {{&notes}}
   {{/notes}}
   {{#summary}}
   * {{&summary}}
   {{/summary}}
   */
  async {{nickname}}Raw({{#allParams.0}}requestParameters: {{#prefixParameterInterfaces}}{{classname}}{{/prefixParameterInterfaces}}{{operationIdCamelCase}}Request{{/allParams.0}}): Promise<runtime.ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}void{{/returnType}}>> {
    {{#allParams}}
    {{#required}}
    if (requestParameters.{{paramName}} === null || requestParameters.{{paramName}} === undefined) {
      throw new runtime.RequiredError('{{paramName}}','Required parameter requestParameters.{{paramName}} was null or undefined when calling {{nickname}}.');
    }

    {{/required}}
    {{/allParams}}
    const queryParameters: any = {};

    {{#queryParams}}
    {{#isListContainer}}
    if (requestParameters.{{paramName}}) {
      {{#isCollectionFormatMulti}}
      queryParameters['{{baseName}}'] = requestParameters.{{paramName}};
      {{/isCollectionFormatMulti}}
      {{^isCollectionFormatMulti}}
      queryParameters['{{baseName}}'] = requestParameters.{{paramName}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]);
      {{/isCollectionFormatMulti}}
    }

    {{/isListContainer}}
    {{^isListContainer}}
    if (requestParameters.{{paramName}} !== undefined) {
      {{#isDateTime}}
      queryParameters['{{baseName}}'] = (requestParameters.{{paramName}} as any).toISOString();
      {{/isDateTime}}
      {{^isDateTime}}
      {{#isDate}}
      queryParameters['{{baseName}}'] = (requestParameters.{{paramName}} as any).toISOString().substr(0,10);
      {{/isDate}}
      {{^isDate}}
      queryParameters['{{baseName}}'] = requestParameters.{{paramName}};
      {{/isDate}}
      {{/isDateTime}}
    }

    {{/isListContainer}}
    {{/queryParams}}
    const headerParameters: runtime.HTTPHeaders = {};

    {{#bodyParam}}
    {{^consumes}}
    headerParameters['Content-Type'] = 'application/json';

    {{/consumes}}
    {{#consumes.0}}
    headerParameters['Content-Type'] = '{{{mediaType}}}';

    {{/consumes.0}}
    {{/bodyParam}}
    {{#headerParams}}
    {{#isListContainer}}
    if (requestParameters.{{paramName}}) {
      headerParameters['{{baseName}}'] = requestParameters.{{paramName}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]);
    }

    {{/isListContainer}}
    {{^isListContainer}}
    {{^required}}
    const {{paramName}}DefaultValue = {{{defaultValue}}};
    if (requestParameters.{{paramName}} !== undefined && requestParameters.{{paramName}} !== null) {
      headerParameters['{{baseName}}'] = String(requestParameters.{{paramName}});
    } else if ({{paramName}}DefaultValue !== undefined && {{paramName}}DefaultValue !== null) {
      headerParameters['{{baseName}}'] = String({{{defaultValue}}});
    }
    {{/required}}
    {{#required}}
    if (requestParameters.{{paramName}} !== undefined && requestParameters.{{paramName}} !== null) {
      headerParameters['{{baseName}}'] = String(requestParameters.{{paramName}});
    }
    {{/required}}

    {{/isListContainer}}
    {{/headerParams}}
    {{#authMethods}}
    {{#isBasic}}
    {{#isBasicBasic}}
    if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    {{/isBasicBasic}}
    {{#isBasicBearer}}
    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = typeof token === 'function' ? token("{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}]) : token;

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    {{/isBasicBearer}}
    {{/isBasic}}
    {{#isApiKey}}
    {{#isKeyInHeader}}
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["{{keyParamName}}"] = this.configuration.apiKey("{{keyParamName}}"); // {{name}} authentication
    }

    {{/isKeyInHeader}}
    {{#isKeyInQuery}}
    if (this.configuration && this.configuration.apiKey) {
      queryParameters["{{keyParamName}}"] = this.configuration.apiKey("{{keyParamName}}"); // {{name}} authentication
    }

    {{/isKeyInQuery}}
    {{/isApiKey}}
    {{#isOAuth}}
    if (this.configuration && this.configuration.accessToken) {
      // oauth required
      if (typeof this.configuration.accessToken === 'function') {
        headerParameters["Authorization"] = this.configuration.accessToken("{{name}}", [{{#scopes}}"{{{scope}}}"{{^-last}}, {{/-last}}{{/scopes}}]);
      } else {
        headerParameters["Authorization"] = this.configuration.accessToken;
      }
    }

    {{/isOAuth}}
    {{/authMethods}}
    {{#hasFormParams}}
    const consumes: runtime.Consume[] = [
      {{#consumes}}
      { contentType: '{{{mediaType}}}' },
      {{/consumes}}
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    {{#formParams}}
    {{#isFile}}
    // use FormData to transmit files using content-type "multipart/form-data"
    useForm = canConsumeForm;
    {{/isFile}}
    {{/formParams}}
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    {{#formParams}}
    {{#isListContainer}}
    if (requestParameters.{{paramName}}) {
      {{#isCollectionFormatMulti}}
      requestParameters.{{paramName}}.forEach((element) => {
        formParams.append('{{baseName}}', element as any);
      })
      {{/isCollectionFormatMulti}}
      {{^isCollectionFormatMulti}}
      formParams.append('{{baseName}}', requestParameters.{{paramName}}.join(runtime.COLLECTION_FORMATS["{{collectionFormat}}"]));
      {{/isCollectionFormatMulti}}
    }

    {{/isListContainer}}
    {{^isListContainer}}
    if (requestParameters.{{paramName}} !== undefined) {
      formParams.append('{{baseName}}', requestParameters.{{paramName}} as any);
    }

    {{/isListContainer}}
    {{/formParams}}
    {{/hasFormParams}}
    const response = await this.request({
      path: `{{{path}}}`{{#pathParams}}.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String(requestParameters.{{paramName}}))){{/pathParams}},
      method: '{{httpMethod}}',
      headers: headerParameters,
      query: queryParameters,
      {{#hasBodyParam}}
      {{#bodyParam}}
      {{#isContainer}}
      body: requestParameters.{{paramName}}{{#isListContainer}}{{#items}}{{^isPrimitiveType}}.map({{datatype}}ToJSON){{/isPrimitiveType}}{{/items}}{{/isListContainer}},
      {{/isContainer}}
      {{^isContainer}}
      {{^isPrimitiveType}}
      body: {{dataType}}ToJSON(requestParameters.{{paramName}}),
      {{/isPrimitiveType}}
      {{#isPrimitiveType}}
      body: requestParameters.{{paramName}} as any,
      {{/isPrimitiveType}}
      {{/isContainer}}
      {{/bodyParam}}
      {{/hasBodyParam}}
      {{#hasFormParams}}
      body: formParams,
      {{/hasFormParams}}
    });

    {{#returnType}}
    {{#isResponseFile}}
    return new runtime.BlobApiResponse(response);
    {{/isResponseFile}}
    {{^isResponseFile}}
    {{#returnTypeIsPrimitive}}
    {{#isMapContainer}}
    return new runtime.JSONApiResponse<any>(response);
    {{/isMapContainer}}
    {{#isListContainer}}
    return new runtime.JSONApiResponse<any>(response);
    {{/isListContainer}}
    {{#returnSimpleType}}
    return new runtime.TextApiResponse(response) as any;
    {{/returnSimpleType}}
    {{/returnTypeIsPrimitive}}
    {{^returnTypeIsPrimitive}}
    {{#isListContainer}}
    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map({{returnBaseType}}FromJSON));
    {{/isListContainer}}
    {{^isListContainer}}
    {{#isMapContainer}}
    return new runtime.JSONApiResponse(response, (jsonValue) => runtime.mapValues(jsonValue, {{returnBaseType}}FromJSON));
    {{/isMapContainer}}
    {{^isMapContainer}}
    return new runtime.JSONApiResponse(response, (jsonValue) => {{returnBaseType}}FromJSON(jsonValue));
    {{/isMapContainer}}
    {{/isListContainer}}
    {{/returnTypeIsPrimitive}}
    {{/isResponseFile}}
    {{/returnType}}
    {{^returnType}}
    return new runtime.VoidApiResponse(response);
    {{/returnType}}
  }

  /**
   {{#notes}}
   * {{&notes}}
   {{/notes}}
   {{#summary}}
   * {{&summary}}
   {{/summary}}
   */
  {{^useSingleRequestParameter}}
  async {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}}{{#hasMore}}, {{/hasMore}}{{/allParams}}): Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}void{{/returnType}}> {
    {{#returnType}}
    const response = await this.{{nickname}}Raw({{#allParams.0}}{ {{#allParams}}{{paramName}}: {{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}} }{{/allParams.0}});
    return await response.value();
    {{/returnType}}
    {{^returnType}}
    await this.{{nickname}}Raw({{#allParams.0}}{ {{#allParams}}{{paramName}}: {{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}} }{{/allParams.0}});
    {{/returnType}}
  }
  {{/useSingleRequestParameter}}
  {{#useSingleRequestParameter}}
  async {{nickname}}({{#allParams.0}}requestParameters: {{#prefixParameterInterfaces}}{{classname}}{{/prefixParameterInterfaces}}{{operationIdCamelCase}}Request{{/allParams.0}}): Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}void{{/returnType}}> {
    {{#returnType}}
    const response = await this.{{nickname}}Raw({{#allParams.0}}requestParameters{{/allParams.0}});
    return await response.value();
    {{/returnType}}
    {{^returnType}}
    await this.{{nickname}}Raw({{#allParams.0}}requestParameters{{/allParams.0}});
    {{/returnType}}
  }
  {{/useSingleRequestParameter}}

  {{/operation}}
}
{{/operations}}
{{#hasEnums}}

{{#operations}}
{{#operation}}
{{#allParams}}
{{#isEnum}}
/**
  * @export
  * @enum {string}
  */
export enum {{operationIdCamelCase}}{{enumName}} {
{{#allowableValues}}
  {{#enumVars}}
  {{{name}}} = {{{value}}}{{^-last}},{{/-last}}
  {{/enumVars}}
{{/allowableValues}}
}
{{/isEnum}}
{{/allParams}}
{{/operation}}
{{/operations}}
{{/hasEnums}}